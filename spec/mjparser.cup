package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, LBRACE, RBRACE, LBRACKET, RBRACKET, SEMI, LPAREN, RPAREN, COMMA, PRINT, RETURN, PLUS, MINUS, EQUAL, VOID, COLON;
terminal Integer NUMBER;
terminal String BOOLCONST;
terminal Character CHARCONST;
terminal String IDENT;
terminal IF, ELSE;
terminal ASTERISK, SLASH, PERCENT, DOT;
terminal DEQUALS, NEQUAL, GEQUAL, LEQUAL, GREATER, LESS;
terminal NEW;
terminal DAMPERSAND, DVBAR;
terminal DPLUS, DMINUS;
terminal DO, WHILE, SWITCH, CASE, BREAK, CONTINUE, READ;
terminal CONST, EXTENDS;
terminal ENUM, QMARK, CLASS;

nonterminal MethodDeclList, VarDecl;
nonterminal FormalParamList, FormalParamDecl, FormPars, ActualPars, ActualParamList; 
nonterminal StatementList, Statement, Addop;
nonterminal Unmatched, Matched;

nonterminal Program, ProgName, Designator, MethodDecl, MethodTypeName, Declaration, MethodType, DesignatorStatement; 
nonterminal Type, Term, Expr, Factor, VarDeclList, DesignatorFactor, MinusSign; 

nonterminal DeclarationList, ClassDecl, VarDeclSemi, ConstDecl, Constant, Extending, MethodDeclBlock, ConstDeclSemi;
nonterminal SwitchCaseList, Condition, Assignop, VarNoType;
nonterminal CondTerm, CondFact, UnsignedExpr, Mulop, NewFactor, Relop, VarDeclarationBlock, StatementBlock, Expr1, BraceMethodDeclBlock;

Program ::= (Program) PROG ProgName:p DeclarationList LBRACE MethodDeclBlock RBRACE;

ProgName ::= (ProgName) IDENT:pName;

DeclarationList ::= (MultiDeclaration) DeclarationList Declaration
						|
					(SingleDeclaration) Declaration
						;

Declaration ::= (VarDeclaration) VarDeclSemi
					|
				(ConstDeclaration) ConstDeclSemi
					|
				(ClassDeclaration) ClassDecl
					//|
				 //error SEMI:g
			   	 //{: parser.report_error("Izvrsen oporavak do ; u liniji " + gleft, null);  :} /* greska globalna def */
					;

ConstDeclSemi ::= (ConstDeclBlockSemi) ConstDecl SEMI;

ConstDecl ::= (MultiConstDecl) ConstDecl COMMA IDENT EQUAL Constant
				|
			  (SingleConstDecl) CONST Type IDENT EQUAL Constant
			  	;  		
			  	
Constant ::= (NumberCon) NUMBER
				|
			  (CharCon) CHARCONST
			  	|
			  (BoolCon) BOOLCONST
			  	;
			  	
VarDeclSemi ::= (VarDeclSemicolon) VarDeclList SEMI;

VarDeclList ::= (MultiVarDecl) VarDeclList COMMA VarNoType
					|
				(SingleVar) VarDecl
					|
				 error:o
			   	 {: parser.report_error("Izvrsen oporavak do , ili ; u liniji " + oleft, null);  :} /* greska globalna def */
					;
	
VarDecl ::= (VarWithType) Type VarNoType;
				
VarNoType ::= (VarIdentSingle) IDENT
				|
			  (VarIdentArray) IDENT LBRACKET RBRACKET
			  	;

Type ::= (Type) IDENT:typeName;

ClassDecl ::= (ClassDecl) CLASS IDENT Extending LBRACE VarDeclarationBlock BraceMethodDeclBlock RBRACE;

Extending ::= (Extended) EXTENDS Type
				|
			  (NotExtended) /* epsilon */
			  	;

BraceMethodDeclBlock ::= (BMDBlock) LBRACE MethodDeclBlock RBRACE;
			  	
MethodDeclBlock ::= (MethodBlock) MethodDeclList 
						|
					(NoMethodBlock) /* epsilon */
						;
						
MethodDeclList ::= (MultiMethodDeclarations) MethodDeclList MethodDecl
						|
				   (SingleMethodDeclaration) MethodDecl
						;

MethodDecl ::= (MethodDeclVars) MethodTypeName LPAREN FormPars RPAREN VarDeclarationBlock LBRACE StatementBlock RBRACE
					|
			   (MethodDeclNoVars) MethodTypeName LPAREN FormPars RPAREN LBRACE StatementBlock RBRACE
					;

MethodTypeName ::= (MethodTypeName) MethodType:retType IDENT:methName;

MethodType ::= (NonVoidType) Type 
				| 
			   (VoidType) VOID
			   	;
			   	
VarDeclarationBlock ::= (MultiVarDeclSemi) VarDeclarationBlock VarDeclSemi
							|
						(SingleVarDeclSemi) VarDeclSemi
							; 

FormPars ::= (FormParams) FormalParamList 
				| 
			 (NoFormParam) /* epsilon */ 
			 	;

FormalParamList ::= (FormalParamDecls) FormalParamList COMMA FormalParamDecl
						|
					(SingleFormalParamDecl) FormalParamDecl
						;
					
FormalParamDecl ::= (FormalParamDecl1) Type IDENT 
						|
					(FormalParamDecl2) Type IDENT LBRACKET RBRACKET
						;

StatementBlock ::= (StmtBlck) StatementList 
					|
				   (NoStmtBlck) /* epsilon */
				  	;

StatementList ::= (MultiStatement) StatementList Statement 
					|
				  (SingleStatement) Statement
				  	;

Statement ::= (MatchedStmt) Matched | (UnmachedStmt) Unmatched ;

Unmatched ::= (UnmatchedIf) IF LPAREN Condition RPAREN Statement | (UnmatchedIfElse) IF LPAREN Condition RPAREN Matched ELSE Unmatched;

				  
Matched ::= (Assignment) DesignatorStatement:dest SEMI 
			  |
			 error SEMI:l
		   	 {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :} /* iskaz dodele */
		   	  |
			(PrintStmt) PRINT LPAREN Expr RPAREN SEMI 
			  |
			(ReturnExpr) RETURN Expr:t SEMI
			  |
	  		(ReturnNoExpr) RETURN SEMI
			  | 
			(MatchedIf) IF LPAREN Condition RPAREN Matched ELSE Matched
			  |
			(DoWhileStmt) DO StatementBlock WHILE LPAREN Condition RPAREN SEMI
			  |
			(SwitchStmt) SWITCH LPAREN Expr RPAREN LBRACE SwitchCaseList RBRACE
			  |
			(BreakStmt) BREAK SEMI
			  |
			(ContinueStmt) CONTINUE SEMI
			  |
			(ReadStmt) READ LPAREN Designator RPAREN SEMI
			  |
			(BlockStmt) LBRACE StatementBlock RBRACE
			  ;

SwitchCaseList ::=  (MultiCase) SwitchCaseList CASE NUMBER COLON StatementList
						| 
				    (SingleCase) CASE NUMBER COLON StatementList
				    	;

DesignatorStatement ::= (AssignmentExpr) Designator Assignop Expr
							|
						(Func) Designator LPAREN ActualPars RPAREN
							|
						(Increment) Designator DPLUS
							|
						(Decrement) Designator DMINUS
							;

ActualPars ::= (Actuals) ActualParamList 
				| 
			   (NoActuals) /* epsilon */ 
			   	;
			   
ActualParamList ::= (ActualParams) ActualParamList COMMA Expr
					|
					(ActualParam) Expr
					;

Condition ::= (MultiCondTerm) Condition DVBAR CondTerm
				|
			  (SingleCondTerm) CondTerm
			  	;

CondTerm ::= (MultiCondFact) CondTerm DAMPERSAND CondFact
				|
			 (SingleCondFact) CondFact
			 	;

CondFact ::= (ExprCondFact) Expr
				|
			 (ERECondFact) Expr Relop Expr
			 	; 

Expr ::= (NormalExpr) Expr1
			|
		 (TernaryExpr) Expr1 QMARK Expr1 COLON Expr1 /* revizirano */
		 	;

Expr1 ::= (PosExpr1) UnsignedExpr
			|
		  (NegExpr1) MINUS UnsignedExpr
		  	;
		 	
UnsignedExpr ::= (AddExpr) UnsignedExpr Addop Term /* Ne moze sa ovim Relop onda */
		  			|		  		 	
		 		 (TermExpr) Term
		 			;

Term ::= (FactorMulopTerm) Term Mulop Factor 
			|
		 (FactorTerm) Factor
		 	;

Factor ::= (Var) Designator
			|
		   (NumConst) NUMBER
		   	|
		   (CharConst) CHARCONST
		   	|
		   (BoolConst) BOOLCONST
		   	|
		   (New) NewFactor
		   	| 
		   (FuncCall) DesignatorFactor
		   	|
		   (ParenExpr) LPAREN Expr RPAREN
		   	;

DesignatorFactor ::= (DesignatorActPars) Designator LPAREN ActualPars RPAREN;

NewFactor ::= (NewFactorSingle) NEW Type
				|
			  (NewFactorArray) NEW Type LBRACKET Expr RBRACKET	
			  	;


Designator ::= (DesignatorField) Designator DOT IDENT:name 
				|
			   (DesignatorIndex) Designator LBRACKET Expr RBRACKET 
				|
			   (SingleDesignator) IDENT:name
				;
					
Assignop ::= (Assignop) EQUAL;

Relop ::= (Equalop) DEQUALS
			|
		  (NotEqualop) NEQUAL
		  	|
		  (Greaterop) GREATER
		  	|
		  (GreaterEqualsop) GEQUAL
		  	| 
		  (Lessop) LESS
		   	| 
		  (LessEqualop) LEQUAL
		  	;  

Addop ::= (Addop) PLUS 
			| 
		  (Subtractop) MINUS
		  	;
			
Mulop ::= (Mulop) ASTERISK
		 	| 
		  (Divideop) SLASH
		 	| 
		  (Modop) PERCENT 
		  	;